排序
------

计数排序
^^^^^^^^^

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中，值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。

- 数据结构：数组

- 最差时间复杂度：O(n + k)

- 最优时间复杂度：O(n + k)

- 平均时间复杂度：O(n + k)

- 最差空间复杂度：O(n + k)

由于用来计数的数组C的长度取决于待排序数组中数据的范围(等于待排序数组的最大值与最小值的差加1)，这使得计数排序对于数据范围很大的数组，需要大量的时间和内存。

**算法步骤:**

#) 找出待排序的数组中最大和最小的元素

#) 统计数组中每个值为i的元素出现的次数，存入数组C的第i项

#) 对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加)

桶排序
^^^^^^^

桶排序(Bucket sort)或所谓箱算法，工作原理是将数组元素分到有限数量的桶子里。每个桶子再个别排序(有可能再使用别的排序算法或以递归方式继续使用桶排序进行排序)。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间(O(n))。桶排序并不是比较排序，不受O(n log n)下限的影响。

- 数据结构：数组

- 最差时间复杂度：O(n^2)

- 平均时间复杂度：O(n + k)

- 最差时间复杂度：O(n)

- 最差空间复杂度：O(n*k)

桶排序的步骤如下:

#) 设置一定量的数组当作空桶子

#) 遍历序列，并且把元素一个一个放到对应的桶子去

#) 对每个不是空的桶子进行排序

#) 从不是空的桶子里把元素再放回原来的序列中。



#) 反向填充目标数组：将每个元素i放到新数组的第C(i)项，每放一个元素就将C(i)减去1